Git architecture and concepts: 
we call them trees because they represent a file structure.

Two tree architecture(two-tree-architecture image): Now the reason why there are two distinct trees is that these files don't have to be the same between them. In which scenarios having two trees is useful?
If I check out copy from the repository, I make some changes into it, I save those changes on my hard drive. Now those changes are saved, they are permanent, they are saved in my working copy, but they're not yet committed to the repository. So my working copy looks different from the repository. Both are saved, it's not like I haven't saved the files, I've done that. They just aren't saved and tracked in the version control repository. Now if the repository is a shared repository, and there are many people working from it, they may commit their changes to the repository. And if I haven't checked out a copy recently to get those changes, then my working copy doesn't have their changes. So once again the repository and the working trees will not have the same information in them. So that's a typical two-tree architecture.

Three tier architecture(three-tier-architecture image): 
Git uses a three-tree architecture. It still has the repository and the working copies, but in between is another tree which is the staging index. In last notes file We added, then we committed, it was a two-step process. That is, we added our files to the staging index, and then from there we committed to the repository.

Now it is possible to go ahead and just commit directly to the repository and skip that staging step. We'll learn how to do that later. 

Why adding three tier architecture is more useful?
Consider a scenario where we want to make changes to ten different files in our working copy but we just want to commit five of these as one changed set. So we can put those five files on the staging index, add them to the staging index, get those five files ready to go, and as soon as we are  satisfied that they are ready, we can commit those five files in one changed set to the repository. The other five files are still saved in my working tree, but they never got added to the staging index or to the repository. They are sitting there waiting for me to make another commit, to stage those changes and then commit them to the repository. And of course we can pull things out of the repository in the same way. It's possible to pull them from the repository to the staging index, from the staging index to the working directory, usually that's not what we do. Usually we go ahead and pull them straight from the repository down to the working directory. And in the process the staging index will be updated too. We have our working copy, where we have our changes that we've made, and we've saved, and saved to our hard drive, but we have not yet committed them to the repository, we haven't told Git to make this a changed set and to track it.

Summary: We have the staging index, which is where we prepare things, we stage them for the commit, and then after they've been staged, we commit them to the repository so that they are permanently tracked and they now have a commit message attached to them.


Git workflow: 
In our example we were using a single file, but these are changed sets, sets of changes, and more often than not they wil refer to multiple files.
Check the image git-wrokflow. 
So in a typical Git workflow, A would represent changes to five files, B would represent changes that were made to three files, C might be two new files that were added to the repository. So A, B, and C are snapshots of the changes that were made not anything to do with files or versions of files. So let's take a look at how Git does refer to these files. When we submit these changes to the repository at that point Git generates a checksum for each changed set. A checksum is a number that's generated by taking data and feeding it into an algorithm, so checksum algorithm converts data into a simple number, and we call that simple number a checksum.

The same data put into the algorithm always equals the same checksum coming out that's important because if we change the data going in we get a different checksum out. So one of the most common uses for checksums in computers is to make sure that the data didn't change, if the data changed well then the checksum will be different. And this data integrity is fundamentally built into Git that's very different from other version control systems, they don't use checksums to validate that the data hasn't change. Git does it makes sure that you can't change what's in a commit or else you'll change the checksum that comes out of it. Changing the data changes the checksum.

Now the way that Git generates this checksum is by using the SHA-1 hash algorithm. You don't need to know anything about that hash algorithm itself, but you do need to know that it's called that because you will often hear people refer to this checksum or hash as being the SHA, or S-H-A value. The number that the algorithm generates is always going to be a 40 character hexadecimal string. Hexadecimal means they can have the numbers 0 through 9 and the letters a through f. So an example might look something like this 5c15e8bd540 and so on, 40 characters long made up of those characters.

So what Git does is it takes the entire set of changes, runs them through in algorithm, and in the end comes out with this one 40 digit number, we've seen this number before. When we get our Git log command here is that ID that I told you to get uses to track each one of our commits, its right there this is the SHA, S-H-A value, or the commit ID, you can call it whatever you want really. But it is a number that will be unique to the changes that are in this commit. 

Check out the image commits-relationship. So the way they get actually attaches that information is that if we have those three snapshot those sets of changes it feeds them into its algorithm to come up with the S-H-A value, and then it attaches a bit of meta information to each one of those snapshots, it has that commit number at the top, it has the parent commit the commit that comes before it, the author of the commit, and then the commit message.

So here you can see how the series of those commits are linked together, you can see that the parent for each one refers to the SHA-1 value of the other one before the identifier that come before, and that's how it knows the sequence of those commits. And then each one of those, each bit of meta information, points at a snapshot a set of changes or a Git object. Understanding how Git generates these hash values is important, because it helps us understand how Git summarizes these snapshots, it illustrates the data integrity that's built into Git, and most importantly we're going to be using these SHA-1 hash values to refer to the commits.

Working with the head pointer: 
Git maintains a reference variable called HEAD, all capitals, H-E-A-D. And we call this variable a pointer, because its purpose is to reference, or point to, a specific commit in the repository as we make new commits the pointer is going to change or move to point to a new commit. HEAD always points to the tip of the current branch in our repository. Now this has to do with our repository, not our staging index, or our working directory, we're talking just about the repository the commits that we've actually made to the repository by checking them in.

Another way to think of it is the last state of our repository or what was last checked out, and because it's where the repository left off or the last state, you can also say that the HEAD points to the parent of the next commit or it's where commit writing is going to take place. I think a good metaphor to think about this is the playback and record head on a cassette tape recorder. As we start recording audio the tape moves past the head, and it records onto it, when we press Stop the place where that record head is stopped is the place it'll start recording again when we press Record a second time.

Now we can move around, we can move the head to different places, but wherever the head is positioned when we hit Record again that's where it's going to start recording. The HEAD pointer in Git is very similar, it points at the place where we're going to start recording next. It's the place where we left off in our repository for the things that we've committed. Let's take a look of some illustrations that will make this clearer. In the last movie we saw how we could refer commits by using the SHA values, and I gave you an illustration like this. Now I want to distill this down and make these three different commits just the first six characters of each of the SHAs, so I'm going to represent each one of these three by just having 5c15e8, 38e73d, and a614b5.

Now can you guess where the HEAD points after we've made these three commits? It points to the tip of the current branch in our repository that's the last commit that we made, it's the parent of the next commit. So when we make another commit will be attached to the end there a614b5 will be the parent, and then we'll make the new commit. Now HEAD becomes especially important when we start talking about branches and branches is something that we'll talk about little later on, but I want to go ahead and just give you the basics of it here. By default the branch that we're working on is the master branch that's our main branch, so let's walk through the master branch and see how the HEAD pointer moves as we make our commits.

So we're going to start out with 5c15e8 as the first commit. At that point the HEAD pointer points to that commit. When we make a new commit it says, oh the parent is going to be 5c15e8, it puts in that new commit, and it moves the HEAD pointer to point to that last commit, the tip of our master branch. And then we make another one it does the same thing it attaches it to the end and moves the HEAD pointer. It's essentially like it moved the record head of the tape recorder forward. Now in Git we have the ability to create new branches that is to create a new set of code that we're working, and it's separate from our master branch, we'll learn how to do that later, but for now let just say that we have a new branch, and that new branch is going to start having its own commits that are separate from master.

When we make the first commit HEAD moves to that commit, and then we make another commit HEAD moves along that and along that. Now we can switch between these branches we can check out one or the other, so if we've have our new branch checked out well then HEAD is pointing at the last commit of the current branch, new branch. If we check out our master branch and switch back there. Well guess what? HEAD moves to point to the tip of the current branch that we have checked out their, master. And if we were to check out new branch again it would switch back and forth.

So HEAD always points to the tip of the currently checked out branch from the repository, don't worry too much of this branching stuff doesn't make total sense just yet we'll get to that later on, and you can always come back and review this movie than if you need to. Let's go to the command line and see how Git actually keeps track of HEAD. So here I am inside my first Git project directory, and you'll remember that inside there we had a folder called .git. So let's change into that folder and just take a peek here, you don't have to follow along with me, if you don't want you can just watch.

Let's look what's in that directory and look here there is a file called HEAD, and that's what Git uses to know where the HEAD is pointing. What is HEAD currently pointing to? I'll take a look at what's inside that file just say cat HEAD, and you'll notice that it says it refers to refs/heads/master, it doesn't point to a current commit, it points to a current branch, but that current branch has a tip it has a latest one, and that is maintained in this refs folder. So it's pointing into this folder, let's go inside refs, let's take a look at what's in there, you'll see that it has heads, and it tells us it's inside refs/heads and master.

Summary: HEAD is just a pointer that goes to the tip of the current branch in the repository.